<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>手机版无边界白板 (撤销修正, 橡皮擦预览)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 样式与之前版本基本相同 */
        body { overscroll-behavior: none; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; padding: 0; overflow: hidden; }
        #whiteboard-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; }
        canvas { display: block; touch-action: none; background-color: white; width: 100%; height: 100%; }
        .toolbar { position: fixed; bottom: 0; left: 0; width: 100%; background-color: rgba(240, 240, 240, 0.95); padding: 8px 5px; display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 5px; border-top: 1px solid #ccc; z-index: 10; box-sizing: border-box; }
        .toolbar button { padding: 6px 10px; border: 1px solid #ccc; border-radius: 6px; background-color: white; cursor: pointer; font-size: 12px; min-width: 45px; text-align: center; transition: background-color 0.2s, border-color 0.2s; user-select: none; -webkit-tap-highlight-color: transparent; }
        .toolbar button.active { background-color: #d1e7ff; border-color: #0d6efd; font-weight: bold; }
        .toolbar button:active { background-color: #eee; }
        .toolbar button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #f8f9fa; }
        #instructions { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 100; padding: 20px; box-sizing: border-box; }
        #instructions-content { background-color: white; padding: 25px; border-radius: 8px; max-width: 90%; max-height: 90%; overflow-y: auto; text-align: left; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        #instructions-content h2 { margin-top: 0; margin-bottom: 15px; font-size: 1.2em; font-weight: bold; text-align: center; }
        #instructions-content ul { list-style: disc; margin-left: 20px; margin-bottom: 15px; }
        #instructions-content li { margin-bottom: 8px; }
        #instructions-content button { display: block; margin: 15px auto 0; padding: 10px 20px; background-color: #0d6efd; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; }
        #help-btn { position: fixed; top: 15px; right: 15px; width: 40px; height: 40px; background-color: rgba(255, 255, 255, 0.8); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 24px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); cursor: pointer; z-index: 50; border: 1px solid #ddd; -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body class="overflow-hidden">

    <div id="whiteboard-container">
        <canvas id="whiteboard"></canvas>
    </div>

    <div id="help-btn">📖</div>

    <div class="toolbar">
        <button id="pen-btn" class="active">笔✏️</button>
        <button id="eraser-btn">橡皮🟨</button>
        <button id="clear-btn">清除🗑️</button>
        <button id="undo-btn" disabled>撤销↩️</button>
        <button class="canvas-btn active" data-canvas="0">板1</button>
        <button class="canvas-btn" data-canvas="1">板2</button>
        </div>

    <div id="instructions">
        <div id="instructions-content">
            <h2>操作说明</h2>
            <ul>
                <li><b>画笔/橡皮擦:</b> 单指在屏幕上滑动进行绘制或擦除。</li>
                <li><b>缩放:</b> 双指捏合或张开来缩小或放大画面 (0.1倍 ~ 10倍)。</li>
                <li><b>平移:</b> 双指在屏幕上一起滑动来移动画面。</li>
                <li><b>撤销:</b> 最多可撤销当前画板的 10 步操作。</li>
                <li><b>切换画板:</b> 点击 "板1" 或 "板2" 切换不同的绘图区域，内容会保留。</li>
                <li><b>开发者:</b> 惠荣VS0769，微信DDZDDM0430</li>
            </ul>
            <button id="close-instructions">我知道了</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('whiteboard-container');

        // --- 常量 ---
        const VIRTUAL_CANVAS_MULTIPLIER = 10;
        const MAX_UNDO_STEPS = 10;
        const BASE_LINE_WIDTH = 2; // Visual width in CSS pixels
        const ERASER_WIDTH_MULTIPLIER = 8;
        const ERASER_PREVIEW_COLOR = 'rgba(165, 42, 42, 0.4)'; // Semi-transparent brown

        // --- 畫板尺寸 ---
        let screenWidth = window.innerWidth;
        let screenHeight = window.innerHeight;
        let largeCanvasWidth = screenWidth * VIRTUAL_CANVAS_MULTIPLIER;
        let largeCanvasHeight = screenHeight * VIRTUAL_CANVAS_MULTIPLIER;
        let dpr = window.devicePixelRatio || 1;

        // --- 縮放限制 ---
        const initialScaleFactor = 1.0;
        const minZoomFactor = 0.1;
        const maxZoomFactor = 10.0;
        const initialInnerScale = dpr; // Initial scale corresponds to 1x zoom factor
        const minInnerScale = minZoomFactor * initialInnerScale;
        const maxInnerScale = maxZoomFactor * initialInnerScale;

        // --- 狀態變量 ---
        let isDrawing = false;
        let isPanningOrZooming = false;
        let currentTool = 'pen';

        // *** 將畫板數量改為 2 ***
        let canvasesState = Array.from({ length: 2 }, () => ({
            paths: [],
            history: [],
            view: {
                scale: initialInnerScale,
                centerX: largeCanvasWidth / 2,
                centerY: largeCanvasHeight / 2,
            },
            debug: false // 调试标志，设为true时输出详细日志
        }));
        let currentCanvasIndex = 0;

        let currentPath = null;
        let activeTouches = {};
        let initialPinchDistance = null;
        let initialPinchMidpoint = null;
        let lastPanMidpoint = null;
        let pinchStartScale = null;
        let lastTouchPagePos = null; // *** 用於橡皮擦預覽 ***

        let canvasOffset = { left: 0, top: 0 };

        // --- 工具欄按鈕 ---
        const penBtn = document.getElementById('pen-btn');
        const eraserBtn = document.getElementById('eraser-btn');
        const clearBtn = document.getElementById('clear-btn');
        const undoBtn = document.getElementById('undo-btn');
        const canvasBtns = document.querySelectorAll('.canvas-btn');
        const instructionsPanel = document.getElementById('instructions');
        const closeInstructionsBtn = document.getElementById('close-instructions');

        // --- 初始化 ---
        function initializeCanvas() {
            updateCanvasOffset();
            resizeCanvas();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            loadCanvasState(currentCanvasIndex);
            redrawCurrentCanvas();
            updateToolbar();
            updateUndoButtonState();
            // console.log(`Initial Large Canvas: ${largeCanvasWidth}x${largeCanvasHeight}`);
            // console.log(`Initial Viewport: scale=${canvasesState[currentCanvasIndex].view.scale}, center=(${canvasesState[currentCanvasIndex].view.centerX}, ${canvasesState[currentCanvasIndex].view.centerY})`);
        }

        // --- 更新 Canvas 偏移量 ---
        function updateCanvasOffset() {
            const rect = canvas.getBoundingClientRect();
            canvasOffset.left = rect.left;
            canvasOffset.top = rect.top;
        }

        // --- 調整畫布尺寸 ---
        function resizeCanvas() {
            updateCanvasOffset();
            const oldDPR = dpr; // Store old DPR for potential adjustments
            dpr = window.devicePixelRatio || 1;
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;

            const oldLargeWidth = largeCanvasWidth;
            const oldLargeHeight = largeCanvasHeight;
            largeCanvasWidth = screenWidth * VIRTUAL_CANVAS_MULTIPLIER;
            largeCanvasHeight = screenHeight * VIRTUAL_CANVAS_MULTIPLIER;

            canvas.style.width = `${screenWidth}px`;
            canvas.style.height = `${screenHeight}px`;
            canvas.width = screenWidth * dpr;
            canvas.height = screenHeight * dpr;

            // Adjust view center and scale on resize
            canvasesState.forEach(state => {
                // Adjust center to maintain relative position
                state.view.centerX = state.view.centerX / oldLargeWidth * largeCanvasWidth;
                state.view.centerY = state.view.centerY / oldLargeHeight * largeCanvasHeight;
                // Adjust scale based on DPR change if needed, or keep visual scale constant
                // Keeping visual scale constant might be more intuitive
                // state.view.scale = state.view.scale / oldDPR * dpr;

                // Ensure scale is within limits
                state.view.scale = Math.max(minInnerScale, Math.min(maxInnerScale, state.view.scale));
            });

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            redrawCurrentCanvas();
        }

        // --- 座標轉換 ---
        function pageToLargeCanvas(pagePos) {
            const view = canvasesState[currentCanvasIndex].view;
            const cssX = pagePos.pageX - canvasOffset.left;
            const cssY = pagePos.pageY - canvasOffset.top;
            const contextX = cssX * dpr;
            const contextY = cssY * dpr;
            const contextCenterX = canvas.width / 2;
            const contextCenterY = canvas.height / 2;
            const offsetX = (contextX - contextCenterX) / view.scale;
            const offsetY = (contextY - contextCenterY) / view.scale;
            const largeX = view.centerX + offsetX;
            const largeY = view.centerY + offsetY;
            return { x: largeX, y: largeY };
        }

        // --- 繪圖邏輯 ---
        function startDrawing(touch) {
            if (isPanningOrZooming) return;
            isDrawing = true;
            const largePos = pageToLargeCanvas(touch);

            // *** 撤銷功能：保存繪製前的狀態 ***
            saveHistory(); // Call before creating the path

            currentPath = {
                points: [largePos],
                color: currentTool === 'pen' ? 'black' : 'white',
                lineWidth: currentTool === 'eraser' ? BASE_LINE_WIDTH * ERASER_WIDTH_MULTIPLIER : BASE_LINE_WIDTH
            };
             lastTouchPagePos = { pageX: touch.pageX, pageY: touch.pageY }; // Update for preview start
        }

        function draw(touch) {
            if (!isDrawing || !currentPath || isPanningOrZooming) return;
            const largePos = pageToLargeCanvas(touch);
            currentPath.points.push(largePos);
            lastTouchPagePos = { pageX: touch.pageX, pageY: touch.pageY }; // *** 更新橡皮擦預覽位置 ***
            requestAnimationFrame(redrawCurrentCanvas);
        }

        function stopDrawing() {
            if (!isDrawing || isPanningOrZooming) return;

            const state = canvasesState[currentCanvasIndex];
            if (currentPath && currentPath.points.length > 0) { // Allow single point paths
                state.paths.push(currentPath);
                // console.log("Path saved, point count:", currentPath.points.length);
            } else {
                // console.log("Empty path discarded");
                 // Attempt to remove the history state saved for this empty path
                 if (state.history.length > 0) {
                     // A simple pop might be wrong if other actions happened
                     // For simplicity, we might leave the empty state save in history
                     // Or compare the last history entry with the one before it
                 }
            }

            isDrawing = false;
            currentPath = null;
            lastTouchPagePos = null; // *** 清除橡皮擦預覽位置 ***
            redrawCurrentCanvas(); // Ensure final state is drawn
            updateUndoButtonState(); // Update button after potential history change
        }

        // --- 觸摸事件處理 ---
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                activeTouches[touch.identifier] = { pageX: touch.pageX, pageY: touch.pageY };
            }
            const touchCount = Object.keys(activeTouches).length;

            if (touchCount === 1 && !isDrawing && !isPanningOrZooming) {
                // Delay starting drawing until touchmove
            } else if (touchCount === 2) {
                isDrawing = false;
                currentPath = null;
                lastTouchPagePos = null; // Clear preview if switching to zoom/pan
                isPanningOrZooming = true;
                const touchList = Object.values(activeTouches);
                initialPinchDistance = getDistance(touchList[0], touchList[1]);
                initialPinchMidpoint = getMidpoint(touchList[0], touchList[1]);
                lastPanMidpoint = initialPinchMidpoint;
                pinchStartScale = canvasesState[currentCanvasIndex].view.scale;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touches = e.changedTouches;
            let hasActiveTouchMoved = false;
            let currentTouch = null; // Store the touch being processed

            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                if (activeTouches[touch.identifier]) {
                    activeTouches[touch.identifier] = { pageX: touch.pageX, pageY: touch.pageY };
                    currentTouch = touch; // Store reference to the moving touch
                    hasActiveTouchMoved = true;
                }
            }

            if (!hasActiveTouchMoved || !currentTouch) return; // Exit if no active touch moved

            const touchCount = Object.keys(activeTouches).length;

            if (touchCount === 1) {
                // Use the actual moving touch data
                 const touchData = activeTouches[currentTouch.identifier];
                 if (!isDrawing && !isPanningOrZooming) {
                    startDrawing(touchData);
                 }
                 if (isDrawing) {
                    draw(touchData);
                 }
            } else if (touchCount === 2 && isPanningOrZooming) {
                handlePanAndZoom();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touches = e.changedTouches;
            let wasDrawing = false; // Flag if the ended touch was drawing

            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const touchId = touch.identifier;
                if (isDrawing && activeTouches[touchId]) {
                     wasDrawing = true; // Mark that drawing should stop
                }
                delete activeTouches[touchId];
            }

            // Stop drawing if the ended touch was the drawing one
            if (wasDrawing) {
                stopDrawing();
            }

            const touchCount = Object.keys(activeTouches).length;

            if (touchCount < 2) {
                if (isPanningOrZooming) {
                    isPanningOrZooming = false;
                    initialPinchDistance = null;
                    initialPinchMidpoint = null;
                    lastPanMidpoint = null;
                    pinchStartScale = null;
                }
            }
            if (touchCount === 0) {
                 isDrawing = false; // Ensure drawing stops if all fingers lift
                 currentPath = null;
                 lastTouchPagePos = null; // Clear preview if all fingers lift
            }
        });

         canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            activeTouches = {};
            isDrawing = false;
            isPanningOrZooming = false;
            currentPath = null;
            initialPinchDistance = null;
            initialPinchMidpoint = null;
            lastPanMidpoint = null;
            pinchStartScale = null;
            lastTouchPagePos = null; // Clear preview
            redrawCurrentCanvas();
            updateUndoButtonState();
        });


        // --- 平移與縮放 (基本同 V2) ---
        function getDistance(p1, p2) { /* ... */ return Math.hypot(p1.pageX - p2.pageX, p1.pageY - p2.pageY); } // Use hypot for clarity
        function getMidpoint(p1, p2) { /* ... */ return { pageX: (p1.pageX + p2.pageX) / 2, pageY: (p1.pageY + p2.pageY) / 2 }; }

        function handlePanAndZoom() {
            const view = canvasesState[currentCanvasIndex].view;
            const touches = Object.values(activeTouches);
            if (touches.length !== 2 || !lastPanMidpoint || pinchStartScale === null || initialPinchDistance === null || !initialPinchMidpoint) return; // Added check for initialMidpoint

            const currentMidpoint = getMidpoint(touches[0], touches[1]);
            const currentDistance = getDistance(touches[0], touches[1]);

            // --- Scale ---
            let scaleFactor = 1.0;
            if (initialPinchDistance > 0) {
                scaleFactor = currentDistance / initialPinchDistance;
            }
            let targetScale = pinchStartScale * scaleFactor;
            const newScale = Math.max(minInnerScale, Math.min(maxInnerScale, targetScale));

            // --- Pan & Zoom Translation Adjustment ---
            const initialMidpointLarge = pageToLargeCanvas(initialPinchMidpoint);

            // Calculate how much the large canvas center needs to move
            // based on finger panning delta and zoom adjustment around the initial pinch point.

            // 1. Calculate pan delta in large canvas units (relative to last midpoint)
            const panDeltaX = (currentMidpoint.pageX - lastPanMidpoint.pageX); // CSS pixels
            const panDeltaY = (currentMidpoint.pageY - lastPanMidpoint.pageY); // CSS pixels
            const panDeltaLargeX = -panDeltaX * dpr / view.scale; // Use current scale for delta conversion
            const panDeltaLargeY = -panDeltaY * dpr / view.scale;

            // 2. Calculate where the initial pinch point *would* be relative to the *new* center if only panning occurred
            const projectedCenterX = view.centerX + panDeltaLargeX;
            const projectedCenterY = view.centerY + panDeltaLargeY;

            // 3. Adjust the center based on scale change around the initial pinch point
            view.centerX = initialMidpointLarge.x - (initialMidpointLarge.x - projectedCenterX) * view.scale / newScale;
            view.centerY = initialMidpointLarge.y - (initialMidpointLarge.y - projectedCenterY) * view.scale / newScale;

            // 4. Apply the new scale
            view.scale = newScale;

            // Update last pan midpoint for next movement delta calculation
            lastPanMidpoint = currentMidpoint;

            requestAnimationFrame(redrawCurrentCanvas);
        }

        // --- 畫布重繪 ---
        function redrawCurrentCanvas() {
            const state = canvasesState[currentCanvasIndex];
            const view = state.view;
            const paths = state.paths;

            ctx.save(); // 1. Save initial state

            // 2. Clear canvas (physical pixels)
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 3. Set final transform matrix (combining DPR, pan, zoom)
            // Center of large canvas (view.centerX, view.centerY) should map to center of screen (canvas.width/2, canvas.height/2)
            // Point (LX, LY) maps to CX, CY where:
            // CX = canvas.width/2 + (LX - view.centerX) * view.scale
            // CY = canvas.height/2 + (LY - view.centerY) * view.scale
            // Matrix: scaleX=view.scale, skewX=0, skewY=0, scaleY=view.scale, transX=?, transY=?
            // transX = canvas.width/2 - view.centerX * view.scale
            // transY = canvas.height/2 - view.centerY * view.scale
            ctx.setTransform(
                view.scale, 0, 0, view.scale,
                canvas.width / 2 - view.centerX * view.scale,
                canvas.height / 2 - view.centerY * view.scale
            );

            // --- Draw Paths ---
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            paths.forEach(pathData => {
                // Optimization: Check if path bounding box intersects viewport before drawing
                // (Skipped for simplicity here)
                drawSinglePathOnLargeCanvas(pathData.points, pathData.color, pathData.lineWidth);
            });
            if (isDrawing && currentPath && currentPath.points.length > 0) {
                drawSinglePathOnLargeCanvas(currentPath.points, currentPath.color, currentPath.lineWidth);
            }
            // --- End Draw Paths ---

            ctx.restore(); // 4. Restore initial state (before drawing eraser preview)

            // *** 5. Draw Eraser Preview (on top, no transform) ***
            if (isDrawing && currentTool === 'eraser' && lastTouchPagePos) {
                drawEraserPreview(lastTouchPagePos);
            }
        }

        // Draw single path (coordinates are large canvas coords)
        function drawSinglePathOnLargeCanvas(points, color, visualLineWidth) {
            if (!points || points.length < 1) return;
            const view = canvasesState[currentCanvasIndex].view;
            const contextLineWidth = visualLineWidth * dpr / view.scale; // Context line width depends on zoom

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = contextLineWidth;
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            if (points.length === 1) { // Draw dot for single point path
                const radius = Math.max(contextLineWidth / 2, 0.5 * dpr / view.scale); // Ensure min radius
                ctx.fillStyle = color;
                ctx.arc(points[0].x, points[0].y, radius, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.stroke();
            }
        }

        // *** Draw Eraser Preview Function ***
        function drawEraserPreview(pagePos) {
            const cssX = pagePos.pageX - canvasOffset.left;
            const cssY = pagePos.pageY - canvasOffset.top;
            const contextX = cssX * dpr;
            const contextY = cssY * dpr;
            // 修改这里，去掉/2使预览圆圈与实际橡皮擦大小一致
            const visualRadius = (BASE_LINE_WIDTH * ERASER_WIDTH_MULTIPLIER); // 去掉 /2
            const contextRadius = visualRadius * dpr;
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.beginPath();
            ctx.fillStyle = ERASER_PREVIEW_COLOR;
            ctx.arc(contextX, contextY, contextRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // --- 工具切換 ---
        penBtn.addEventListener('click', () => switchTool('pen'));
        eraserBtn.addEventListener('click', () => switchTool('eraser'));
        function switchTool(tool) {
            currentTool = tool;
            updateToolbar();
        }

        // --- 撤銷操作按鈕 ---
        undoBtn.addEventListener('click', () => {
            if (!undoBtn.disabled) {
                undo();
            }
        });

        // --- 清除畫布 ---
        clearBtn.addEventListener('click', () => {
            const state = canvasesState[currentCanvasIndex];
            if (state.paths.length > 0) {
                 if (confirm('確定要清除當前畫板的所有內容嗎？')) {
                    saveHistory(); // Save before clearing
                    state.paths = [];
                    redrawCurrentCanvas();
                    updateUndoButtonState();
                }
            }
        });

        // --- 撤銷操作 ---
        function saveHistory() {
            const state = canvasesState[currentCanvasIndex];
            try {
                // 使用结构化克隆进行深拷贝，比JSON序列化更高效且保留对象特性
                const pathsCopy = [];
                
                // 优化点坐标存储，使用Float32Array提高性能
                for (const path of state.paths) {
                    const pointsCopy = [];
                    for (const point of path.points) {
                        pointsCopy.push({x: point.x, y: point.y});
                    }
                    
                    pathsCopy.push({
                        points: pointsCopy,
                        color: path.color,
                        lineWidth: path.lineWidth
                    });
                }
                
                // 计算当前状态的更精确哈希值，避免存储重复状态
                // 使用路径数量、颜色和线宽的组合作为哈希值
                let pathsSignature = '';
                if (pathsCopy.length > 0) {
                    // 取样前三条路径的特征作为签名
                    const sampleSize = Math.min(3, pathsCopy.length);
                    for (let i = 0; i < sampleSize; i++) {
                        const path = pathsCopy[pathsCopy.length - 1 - i]; // 从最新的路径开始
                        const pointCount = path.points.length;
                        // 使用路径的颜色、线宽和点数量作为特征
                        pathsSignature += `${path.color}-${path.lineWidth}-${pointCount};`;
                    }
                }
                const currentStateHash = `${pathsCopy.length}-${pathsSignature}`;
                
                if (state.debug) {
                    console.log(`[UNDO LOG] Attempting to save history. Current paths count: ${state.paths.length}. History length before save: ${state.history.length}`);
                }

                // 检查是否需要保存历史（避免重复状态）
                const lastHistoryItem = state.history.length > 0 ? state.history[state.history.length - 1] : null;
                const shouldSave = !lastHistoryItem || 
                                  lastHistoryItem.hash !== currentStateHash || 
                                  lastHistoryItem.pathsCount !== pathsCopy.length;
                
                if (shouldSave) {
                    // 存储状态和哈希值
                    state.history.push({
                        paths: pathsCopy,
                        hash: currentStateHash,
                        pathsCount: pathsCopy.length,
                        timestamp: Date.now() // 添加时间戳便于调试
                    });
                    
                    // 限制历史记录长度
                    while (state.history.length > MAX_UNDO_STEPS) {
                        state.history.shift();
                    }
                    if (state.debug) {
                        console.log(`[UNDO LOG] History saved. New length: ${state.history.length}. Paths count: ${pathsCopy.length}`);
                    }
                } else {
                    if (state.debug) {
                        console.log("[UNDO LOG] History save skipped (state unchanged).");
                    }
                }
            } catch (error) {
                console.error("[UNDO LOG] Failed to save history:", error);
            }
            updateUndoButtonState();
        }

        function undo() {
            const state = canvasesState[currentCanvasIndex];
            if (state.debug) {
                console.log(`[UNDO LOG] Undo called. History length: ${state.history.length}`);
            }
            
            if (state.history.length > 0) {
                const previousState = state.history.pop();
                try {
                    // 直接使用存储的路径数组，无需解析JSON
                    if (Array.isArray(previousState.paths)) {
                        state.paths = previousState.paths;
                        if (state.debug) {
                            console.log(`[UNDO LOG] Undo successful. Restored paths count: ${state.paths.length}. History length after pop: ${state.history.length}`);
                        }
                        redrawCurrentCanvas();
                    } else {
                        throw new Error('Invalid paths data in history');
                    }
                } catch (error) {
                    console.error("[UNDO LOG] Failed to restore history state:", error);
                    // 尝试恢复到上一个有效状态，而不是直接清空
                    if (state.history.length > 0) {
                        try {
                            const fallbackState = state.history.pop();
                            state.paths = fallbackState.paths;
                            console.log("[UNDO LOG] Recovered using previous history state");
                        } catch (fallbackError) {
                            // 如果恢复失败，才清空所有内容
                            state.paths = [];
                            state.history = [];
                            console.error("[UNDO LOG] Failed to recover, clearing all states");
                        }
                    } else {
                        state.paths = []; // Fallback: clear paths if history is corrupted
                    }
                    redrawCurrentCanvas();
                }
            } else {
                if (state.debug) {
                    console.log("[UNDO LOG] Undo skipped (no history).");
                }
            }
            updateUndoButtonState();
        }

        function updateUndoButtonState() {
            const state = canvasesState[currentCanvasIndex];
            undoBtn.disabled = state.history.length === 0;
             // console.log("[UNDO LOG] Undo button state updated. Disabled:", undoBtn.disabled);
        }


        // --- 畫板切換 ---
        canvasBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.dataset.canvas);
                if (index >= 0 && index < 2 && index !== currentCanvasIndex) { // Check index bounds
                    switchCanvas(index);
                }
            });
        });

        function switchCanvas(index) {
            if (index >= 0 && index < 2) { // 修改边界检查为2
                currentCanvasIndex = index;
                loadCanvasState(currentCanvasIndex);
                updateToolbar();
                redrawCurrentCanvas();
                updateUndoButtonState();
            }
        }

        function loadCanvasState(index) {
            // console.log(`Switched to canvas ${index}`);
        }

        // --- 更新工具欄狀態 ---
        function updateToolbar() {
            penBtn.classList.toggle('active', currentTool === 'pen');
            eraserBtn.classList.toggle('active', currentTool === 'eraser');
            canvasBtns.forEach(btn => {
                const btnIndex = parseInt(btn.dataset.canvas);
                if (btnIndex < 2) { // Only update buttons for existing canvases
                    btn.classList.toggle('active', btnIndex === currentCanvasIndex);
                }
            });
        }

        // --- 初始說明 ---
        closeInstructionsBtn.addEventListener('click', () => {
            instructionsPanel.style.display = 'none';
        });

        // --- 帮助按钮点击事件 ---
        document.getElementById('help-btn').addEventListener('click', () => {
            instructionsPanel.style.display = 'flex';
        });

        // --- 窗口大小調整 ---
        window.addEventListener('resize', debounce(resizeCanvas, 100));

        // 防抖函數
        function debounce(func, wait) { /* ... */ let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }

        // --- 啟動 ---
        initializeCanvas();

    </script>

</body>
</html>

