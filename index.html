<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ‰‹æœºç‰ˆæ— è¾¹ç•Œç™½æ¿ (æ’¤é”€ä¿®æ­£, æ©¡çš®æ“¦é¢„è§ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* æ ·å¼ä¸ä¹‹å‰ç‰ˆæœ¬åŸºæœ¬ç›¸åŒ */
        body { overscroll-behavior: none; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; padding: 0; overflow: hidden; }
        #whiteboard-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; }
        canvas { display: block; touch-action: none; background-color: white; width: 100%; height: 100%; }
        .toolbar { position: fixed; bottom: 0; left: 0; width: 100%; background-color: rgba(240, 240, 240, 0.95); padding: 8px 5px; display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 5px; border-top: 1px solid #ccc; z-index: 10; box-sizing: border-box; }
        .toolbar button { padding: 6px 10px; border: 1px solid #ccc; border-radius: 6px; background-color: white; cursor: pointer; font-size: 12px; min-width: 45px; text-align: center; transition: background-color 0.2s, border-color 0.2s; user-select: none; -webkit-tap-highlight-color: transparent; }
        .toolbar button.active { background-color: #d1e7ff; border-color: #0d6efd; font-weight: bold; }
        .toolbar button:active { background-color: #eee; }
        .toolbar button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #f8f9fa; }
        #instructions { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 100; padding: 20px; box-sizing: border-box; }
        #instructions-content { background-color: white; padding: 25px; border-radius: 8px; max-width: 90%; max-height: 90%; overflow-y: auto; text-align: left; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        #instructions-content h2 { margin-top: 0; margin-bottom: 15px; font-size: 1.2em; font-weight: bold; text-align: center; }
        #instructions-content ul { list-style: disc; margin-left: 20px; margin-bottom: 15px; }
        #instructions-content li { margin-bottom: 8px; }
        #instructions-content button { display: block; margin: 15px auto 0; padding: 10px 20px; background-color: #0d6efd; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; }
        #help-btn { position: fixed; top: 15px; right: 15px; width: 40px; height: 40px; background-color: rgba(255, 255, 255, 0.8); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 24px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); cursor: pointer; z-index: 50; border: 1px solid #ddd; -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body class="overflow-hidden">

    <div id="whiteboard-container">
        <canvas id="whiteboard"></canvas>
    </div>

    <div id="help-btn">ğŸ“–</div>

    <div class="toolbar">
        <button id="pen-btn" class="active">ç¬”âœï¸</button>
        <button id="eraser-btn">æ©¡çš®ğŸŸ¨</button>
        <button id="clear-btn">æ¸…é™¤ğŸ—‘ï¸</button>
        <button id="undo-btn" disabled>æ’¤é”€â†©ï¸</button>
        <button class="canvas-btn active" data-canvas="0">æ¿1</button>
        <button class="canvas-btn" data-canvas="1">æ¿2</button>
        </div>

    <div id="instructions">
        <div id="instructions-content">
            <h2>æ“ä½œè¯´æ˜</h2>
            <ul>
                <li><b>ç”»ç¬”/æ©¡çš®æ“¦:</b> å•æŒ‡åœ¨å±å¹•ä¸Šæ»‘åŠ¨è¿›è¡Œç»˜åˆ¶æˆ–æ“¦é™¤ã€‚</li>
                <li><b>ç¼©æ”¾:</b> åŒæŒ‡æåˆæˆ–å¼ å¼€æ¥ç¼©å°æˆ–æ”¾å¤§ç”»é¢ (0.1å€ ~ 10å€)ã€‚</li>
                <li><b>å¹³ç§»:</b> åŒæŒ‡åœ¨å±å¹•ä¸Šä¸€èµ·æ»‘åŠ¨æ¥ç§»åŠ¨ç”»é¢ã€‚</li>
                <li><b>æ’¤é”€:</b> æœ€å¤šå¯æ’¤é”€å½“å‰ç”»æ¿çš„ 10 æ­¥æ“ä½œã€‚</li>
                <li><b>åˆ‡æ¢ç”»æ¿:</b> ç‚¹å‡» "æ¿1" æˆ– "æ¿2" åˆ‡æ¢ä¸åŒçš„ç»˜å›¾åŒºåŸŸï¼Œå†…å®¹ä¼šä¿ç•™ã€‚</li>
                <li><b>å¼€å‘è€…:</b> æƒ è£VS0769ï¼Œå¾®ä¿¡DDZDDM0430</li>
            </ul>
            <button id="close-instructions">æˆ‘çŸ¥é“äº†</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('whiteboard-container');

        // --- å¸¸é‡ ---
        const VIRTUAL_CANVAS_MULTIPLIER = 10;
        const MAX_UNDO_STEPS = 10;
        const BASE_LINE_WIDTH = 2; // Visual width in CSS pixels
        const ERASER_WIDTH_MULTIPLIER = 8;
        const ERASER_PREVIEW_COLOR = 'rgba(165, 42, 42, 0.4)'; // Semi-transparent brown

        // --- ç•«æ¿å°ºå¯¸ ---
        let screenWidth = window.innerWidth;
        let screenHeight = window.innerHeight;
        let largeCanvasWidth = screenWidth * VIRTUAL_CANVAS_MULTIPLIER;
        let largeCanvasHeight = screenHeight * VIRTUAL_CANVAS_MULTIPLIER;
        let dpr = window.devicePixelRatio || 1;

        // --- ç¸®æ”¾é™åˆ¶ ---
        const initialScaleFactor = 1.0;
        const minZoomFactor = 0.1;
        const maxZoomFactor = 10.0;
        const initialInnerScale = dpr; // Initial scale corresponds to 1x zoom factor
        const minInnerScale = minZoomFactor * initialInnerScale;
        const maxInnerScale = maxZoomFactor * initialInnerScale;

        // --- ç‹€æ…‹è®Šé‡ ---
        let isDrawing = false;
        let isPanningOrZooming = false;
        let currentTool = 'pen';

        // *** å°‡ç•«æ¿æ•¸é‡æ”¹ç‚º 2 ***
        let canvasesState = Array.from({ length: 2 }, () => ({
            paths: [],
            history: [],
            view: {
                scale: initialInnerScale,
                centerX: largeCanvasWidth / 2,
                centerY: largeCanvasHeight / 2,
            },
            debug: false // è°ƒè¯•æ ‡å¿—ï¼Œè®¾ä¸ºtrueæ—¶è¾“å‡ºè¯¦ç»†æ—¥å¿—
        }));
        let currentCanvasIndex = 0;

        let currentPath = null;
        let activeTouches = {};
        let initialPinchDistance = null;
        let initialPinchMidpoint = null;
        let lastPanMidpoint = null;
        let pinchStartScale = null;
        let lastTouchPagePos = null; // *** ç”¨æ–¼æ©¡çš®æ“¦é è¦½ ***

        let canvasOffset = { left: 0, top: 0 };

        // --- å·¥å…·æ¬„æŒ‰éˆ• ---
        const penBtn = document.getElementById('pen-btn');
        const eraserBtn = document.getElementById('eraser-btn');
        const clearBtn = document.getElementById('clear-btn');
        const undoBtn = document.getElementById('undo-btn');
        const canvasBtns = document.querySelectorAll('.canvas-btn');
        const instructionsPanel = document.getElementById('instructions');
        const closeInstructionsBtn = document.getElementById('close-instructions');

        // --- åˆå§‹åŒ– ---
        function initializeCanvas() {
            updateCanvasOffset();
            resizeCanvas();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            loadCanvasState(currentCanvasIndex);
            redrawCurrentCanvas();
            updateToolbar();
            updateUndoButtonState();
            // console.log(`Initial Large Canvas: ${largeCanvasWidth}x${largeCanvasHeight}`);
            // console.log(`Initial Viewport: scale=${canvasesState[currentCanvasIndex].view.scale}, center=(${canvasesState[currentCanvasIndex].view.centerX}, ${canvasesState[currentCanvasIndex].view.centerY})`);
        }

        // --- æ›´æ–° Canvas åç§»é‡ ---
        function updateCanvasOffset() {
            const rect = canvas.getBoundingClientRect();
            canvasOffset.left = rect.left;
            canvasOffset.top = rect.top;
        }

        // --- èª¿æ•´ç•«å¸ƒå°ºå¯¸ ---
        function resizeCanvas() {
            updateCanvasOffset();
            const oldDPR = dpr; // Store old DPR for potential adjustments
            dpr = window.devicePixelRatio || 1;
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;

            const oldLargeWidth = largeCanvasWidth;
            const oldLargeHeight = largeCanvasHeight;
            largeCanvasWidth = screenWidth * VIRTUAL_CANVAS_MULTIPLIER;
            largeCanvasHeight = screenHeight * VIRTUAL_CANVAS_MULTIPLIER;

            canvas.style.width = `${screenWidth}px`;
            canvas.style.height = `${screenHeight}px`;
            canvas.width = screenWidth * dpr;
            canvas.height = screenHeight * dpr;

            // Adjust view center and scale on resize
            canvasesState.forEach(state => {
                // Adjust center to maintain relative position
                state.view.centerX = state.view.centerX / oldLargeWidth * largeCanvasWidth;
                state.view.centerY = state.view.centerY / oldLargeHeight * largeCanvasHeight;
                // Adjust scale based on DPR change if needed, or keep visual scale constant
                // Keeping visual scale constant might be more intuitive
                // state.view.scale = state.view.scale / oldDPR * dpr;

                // Ensure scale is within limits
                state.view.scale = Math.max(minInnerScale, Math.min(maxInnerScale, state.view.scale));
            });

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            redrawCurrentCanvas();
        }

        // --- åº§æ¨™è½‰æ› ---
        function pageToLargeCanvas(pagePos) {
            const view = canvasesState[currentCanvasIndex].view;
            const cssX = pagePos.pageX - canvasOffset.left;
            const cssY = pagePos.pageY - canvasOffset.top;
            const contextX = cssX * dpr;
            const contextY = cssY * dpr;
            const contextCenterX = canvas.width / 2;
            const contextCenterY = canvas.height / 2;
            const offsetX = (contextX - contextCenterX) / view.scale;
            const offsetY = (contextY - contextCenterY) / view.scale;
            const largeX = view.centerX + offsetX;
            const largeY = view.centerY + offsetY;
            return { x: largeX, y: largeY };
        }

        // --- ç¹ªåœ–é‚è¼¯ ---
        function startDrawing(touch) {
            if (isPanningOrZooming) return;
            isDrawing = true;
            const largePos = pageToLargeCanvas(touch);

            // *** æ’¤éŠ·åŠŸèƒ½ï¼šä¿å­˜ç¹ªè£½å‰çš„ç‹€æ…‹ ***
            saveHistory(); // Call before creating the path

            currentPath = {
                points: [largePos],
                color: currentTool === 'pen' ? 'black' : 'white',
                lineWidth: currentTool === 'eraser' ? BASE_LINE_WIDTH * ERASER_WIDTH_MULTIPLIER : BASE_LINE_WIDTH
            };
             lastTouchPagePos = { pageX: touch.pageX, pageY: touch.pageY }; // Update for preview start
        }

        function draw(touch) {
            if (!isDrawing || !currentPath || isPanningOrZooming) return;
            const largePos = pageToLargeCanvas(touch);
            currentPath.points.push(largePos);
            lastTouchPagePos = { pageX: touch.pageX, pageY: touch.pageY }; // *** æ›´æ–°æ©¡çš®æ“¦é è¦½ä½ç½® ***
            requestAnimationFrame(redrawCurrentCanvas);
        }

        function stopDrawing() {
            if (!isDrawing || isPanningOrZooming) return;

            const state = canvasesState[currentCanvasIndex];
            if (currentPath && currentPath.points.length > 0) { // Allow single point paths
                state.paths.push(currentPath);
                // console.log("Path saved, point count:", currentPath.points.length);
            } else {
                // console.log("Empty path discarded");
                 // Attempt to remove the history state saved for this empty path
                 if (state.history.length > 0) {
                     // A simple pop might be wrong if other actions happened
                     // For simplicity, we might leave the empty state save in history
                     // Or compare the last history entry with the one before it
                 }
            }

            isDrawing = false;
            currentPath = null;
            lastTouchPagePos = null; // *** æ¸…é™¤æ©¡çš®æ“¦é è¦½ä½ç½® ***
            redrawCurrentCanvas(); // Ensure final state is drawn
            updateUndoButtonState(); // Update button after potential history change
        }

        // --- è§¸æ‘¸äº‹ä»¶è™•ç† ---
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touches = e.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                activeTouches[touch.identifier] = { pageX: touch.pageX, pageY: touch.pageY };
            }
            const touchCount = Object.keys(activeTouches).length;

            if (touchCount === 1 && !isDrawing && !isPanningOrZooming) {
                // Delay starting drawing until touchmove
            } else if (touchCount === 2) {
                isDrawing = false;
                currentPath = null;
                lastTouchPagePos = null; // Clear preview if switching to zoom/pan
                isPanningOrZooming = true;
                const touchList = Object.values(activeTouches);
                initialPinchDistance = getDistance(touchList[0], touchList[1]);
                initialPinchMidpoint = getMidpoint(touchList[0], touchList[1]);
                lastPanMidpoint = initialPinchMidpoint;
                pinchStartScale = canvasesState[currentCanvasIndex].view.scale;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touches = e.changedTouches;
            let hasActiveTouchMoved = false;
            let currentTouch = null; // Store the touch being processed

            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                if (activeTouches[touch.identifier]) {
                    activeTouches[touch.identifier] = { pageX: touch.pageX, pageY: touch.pageY };
                    currentTouch = touch; // Store reference to the moving touch
                    hasActiveTouchMoved = true;
                }
            }

            if (!hasActiveTouchMoved || !currentTouch) return; // Exit if no active touch moved

            const touchCount = Object.keys(activeTouches).length;

            if (touchCount === 1) {
                // Use the actual moving touch data
                 const touchData = activeTouches[currentTouch.identifier];
                 if (!isDrawing && !isPanningOrZooming) {
                    startDrawing(touchData);
                 }
                 if (isDrawing) {
                    draw(touchData);
                 }
            } else if (touchCount === 2 && isPanningOrZooming) {
                handlePanAndZoom();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touches = e.changedTouches;
            let wasDrawing = false; // Flag if the ended touch was drawing

            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const touchId = touch.identifier;
                if (isDrawing && activeTouches[touchId]) {
                     wasDrawing = true; // Mark that drawing should stop
                }
                delete activeTouches[touchId];
            }

            // Stop drawing if the ended touch was the drawing one
            if (wasDrawing) {
                stopDrawing();
            }

            const touchCount = Object.keys(activeTouches).length;

            if (touchCount < 2) {
                if (isPanningOrZooming) {
                    isPanningOrZooming = false;
                    initialPinchDistance = null;
                    initialPinchMidpoint = null;
                    lastPanMidpoint = null;
                    pinchStartScale = null;
                }
            }
            if (touchCount === 0) {
                 isDrawing = false; // Ensure drawing stops if all fingers lift
                 currentPath = null;
                 lastTouchPagePos = null; // Clear preview if all fingers lift
            }
        });

         canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            activeTouches = {};
            isDrawing = false;
            isPanningOrZooming = false;
            currentPath = null;
            initialPinchDistance = null;
            initialPinchMidpoint = null;
            lastPanMidpoint = null;
            pinchStartScale = null;
            lastTouchPagePos = null; // Clear preview
            redrawCurrentCanvas();
            updateUndoButtonState();
        });


        // --- å¹³ç§»èˆ‡ç¸®æ”¾ (åŸºæœ¬åŒ V2) ---
        function getDistance(p1, p2) { /* ... */ return Math.hypot(p1.pageX - p2.pageX, p1.pageY - p2.pageY); } // Use hypot for clarity
        function getMidpoint(p1, p2) { /* ... */ return { pageX: (p1.pageX + p2.pageX) / 2, pageY: (p1.pageY + p2.pageY) / 2 }; }

        function handlePanAndZoom() {
            const view = canvasesState[currentCanvasIndex].view;
            const touches = Object.values(activeTouches);
            if (touches.length !== 2 || !lastPanMidpoint || pinchStartScale === null || initialPinchDistance === null || !initialPinchMidpoint) return; // Added check for initialMidpoint

            const currentMidpoint = getMidpoint(touches[0], touches[1]);
            const currentDistance = getDistance(touches[0], touches[1]);

            // --- Scale ---
            let scaleFactor = 1.0;
            if (initialPinchDistance > 0) {
                scaleFactor = currentDistance / initialPinchDistance;
            }
            let targetScale = pinchStartScale * scaleFactor;
            const newScale = Math.max(minInnerScale, Math.min(maxInnerScale, targetScale));

            // --- Pan & Zoom Translation Adjustment ---
            const initialMidpointLarge = pageToLargeCanvas(initialPinchMidpoint);

            // Calculate how much the large canvas center needs to move
            // based on finger panning delta and zoom adjustment around the initial pinch point.

            // 1. Calculate pan delta in large canvas units (relative to last midpoint)
            const panDeltaX = (currentMidpoint.pageX - lastPanMidpoint.pageX); // CSS pixels
            const panDeltaY = (currentMidpoint.pageY - lastPanMidpoint.pageY); // CSS pixels
            const panDeltaLargeX = -panDeltaX * dpr / view.scale; // Use current scale for delta conversion
            const panDeltaLargeY = -panDeltaY * dpr / view.scale;

            // 2. Calculate where the initial pinch point *would* be relative to the *new* center if only panning occurred
            const projectedCenterX = view.centerX + panDeltaLargeX;
            const projectedCenterY = view.centerY + panDeltaLargeY;

            // 3. Adjust the center based on scale change around the initial pinch point
            view.centerX = initialMidpointLarge.x - (initialMidpointLarge.x - projectedCenterX) * view.scale / newScale;
            view.centerY = initialMidpointLarge.y - (initialMidpointLarge.y - projectedCenterY) * view.scale / newScale;

            // 4. Apply the new scale
            view.scale = newScale;

            // Update last pan midpoint for next movement delta calculation
            lastPanMidpoint = currentMidpoint;

            requestAnimationFrame(redrawCurrentCanvas);
        }

        // --- ç•«å¸ƒé‡ç¹ª ---
        function redrawCurrentCanvas() {
            const state = canvasesState[currentCanvasIndex];
            const view = state.view;
            const paths = state.paths;

            ctx.save(); // 1. Save initial state

            // 2. Clear canvas (physical pixels)
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 3. Set final transform matrix (combining DPR, pan, zoom)
            // Center of large canvas (view.centerX, view.centerY) should map to center of screen (canvas.width/2, canvas.height/2)
            // Point (LX, LY) maps to CX, CY where:
            // CX = canvas.width/2 + (LX - view.centerX) * view.scale
            // CY = canvas.height/2 + (LY - view.centerY) * view.scale
            // Matrix: scaleX=view.scale, skewX=0, skewY=0, scaleY=view.scale, transX=?, transY=?
            // transX = canvas.width/2 - view.centerX * view.scale
            // transY = canvas.height/2 - view.centerY * view.scale
            ctx.setTransform(
                view.scale, 0, 0, view.scale,
                canvas.width / 2 - view.centerX * view.scale,
                canvas.height / 2 - view.centerY * view.scale
            );

            // --- Draw Paths ---
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            paths.forEach(pathData => {
                // Optimization: Check if path bounding box intersects viewport before drawing
                // (Skipped for simplicity here)
                drawSinglePathOnLargeCanvas(pathData.points, pathData.color, pathData.lineWidth);
            });
            if (isDrawing && currentPath && currentPath.points.length > 0) {
                drawSinglePathOnLargeCanvas(currentPath.points, currentPath.color, currentPath.lineWidth);
            }
            // --- End Draw Paths ---

            ctx.restore(); // 4. Restore initial state (before drawing eraser preview)

            // *** 5. Draw Eraser Preview (on top, no transform) ***
            if (isDrawing && currentTool === 'eraser' && lastTouchPagePos) {
                drawEraserPreview(lastTouchPagePos);
            }
        }

        // Draw single path (coordinates are large canvas coords)
        function drawSinglePathOnLargeCanvas(points, color, visualLineWidth) {
            if (!points || points.length < 1) return;
            const view = canvasesState[currentCanvasIndex].view;
            const contextLineWidth = visualLineWidth * dpr / view.scale; // Context line width depends on zoom

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = contextLineWidth;
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            if (points.length === 1) { // Draw dot for single point path
                const radius = Math.max(contextLineWidth / 2, 0.5 * dpr / view.scale); // Ensure min radius
                ctx.fillStyle = color;
                ctx.arc(points[0].x, points[0].y, radius, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.stroke();
            }
        }

        // *** Draw Eraser Preview Function ***
        function drawEraserPreview(pagePos) {
            const cssX = pagePos.pageX - canvasOffset.left;
            const cssY = pagePos.pageY - canvasOffset.top;
            const contextX = cssX * dpr;
            const contextY = cssY * dpr;
            // ä¿®æ”¹è¿™é‡Œï¼Œå»æ‰/2ä½¿é¢„è§ˆåœ†åœˆä¸å®é™…æ©¡çš®æ“¦å¤§å°ä¸€è‡´
            const visualRadius = (BASE_LINE_WIDTH * ERASER_WIDTH_MULTIPLIER); // å»æ‰ /2
            const contextRadius = visualRadius * dpr;
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.beginPath();
            ctx.fillStyle = ERASER_PREVIEW_COLOR;
            ctx.arc(contextX, contextY, contextRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // --- å·¥å…·åˆ‡æ› ---
        penBtn.addEventListener('click', () => switchTool('pen'));
        eraserBtn.addEventListener('click', () => switchTool('eraser'));
        function switchTool(tool) {
            currentTool = tool;
            updateToolbar();
        }

        // --- æ’¤éŠ·æ“ä½œæŒ‰éˆ• ---
        undoBtn.addEventListener('click', () => {
            if (!undoBtn.disabled) {
                undo();
            }
        });

        // --- æ¸…é™¤ç•«å¸ƒ ---
        clearBtn.addEventListener('click', () => {
            const state = canvasesState[currentCanvasIndex];
            if (state.paths.length > 0) {
                 if (confirm('ç¢ºå®šè¦æ¸…é™¤ç•¶å‰ç•«æ¿çš„æ‰€æœ‰å…§å®¹å—ï¼Ÿ')) {
                    saveHistory(); // Save before clearing
                    state.paths = [];
                    redrawCurrentCanvas();
                    updateUndoButtonState();
                }
            }
        });

        // --- æ’¤éŠ·æ“ä½œ ---
        function saveHistory() {
            const state = canvasesState[currentCanvasIndex];
            try {
                // ä½¿ç”¨ç»“æ„åŒ–å…‹éš†è¿›è¡Œæ·±æ‹·è´ï¼Œæ¯”JSONåºåˆ—åŒ–æ›´é«˜æ•ˆä¸”ä¿ç•™å¯¹è±¡ç‰¹æ€§
                const pathsCopy = [];
                
                // ä¼˜åŒ–ç‚¹åæ ‡å­˜å‚¨ï¼Œä½¿ç”¨Float32Arrayæé«˜æ€§èƒ½
                for (const path of state.paths) {
                    const pointsCopy = [];
                    for (const point of path.points) {
                        pointsCopy.push({x: point.x, y: point.y});
                    }
                    
                    pathsCopy.push({
                        points: pointsCopy,
                        color: path.color,
                        lineWidth: path.lineWidth
                    });
                }
                
                // è®¡ç®—å½“å‰çŠ¶æ€çš„æ›´ç²¾ç¡®å“ˆå¸Œå€¼ï¼Œé¿å…å­˜å‚¨é‡å¤çŠ¶æ€
                // ä½¿ç”¨è·¯å¾„æ•°é‡ã€é¢œè‰²å’Œçº¿å®½çš„ç»„åˆä½œä¸ºå“ˆå¸Œå€¼
                let pathsSignature = '';
                if (pathsCopy.length > 0) {
                    // å–æ ·å‰ä¸‰æ¡è·¯å¾„çš„ç‰¹å¾ä½œä¸ºç­¾å
                    const sampleSize = Math.min(3, pathsCopy.length);
                    for (let i = 0; i < sampleSize; i++) {
                        const path = pathsCopy[pathsCopy.length - 1 - i]; // ä»æœ€æ–°çš„è·¯å¾„å¼€å§‹
                        const pointCount = path.points.length;
                        // ä½¿ç”¨è·¯å¾„çš„é¢œè‰²ã€çº¿å®½å’Œç‚¹æ•°é‡ä½œä¸ºç‰¹å¾
                        pathsSignature += `${path.color}-${path.lineWidth}-${pointCount};`;
                    }
                }
                const currentStateHash = `${pathsCopy.length}-${pathsSignature}`;
                
                if (state.debug) {
                    console.log(`[UNDO LOG] Attempting to save history. Current paths count: ${state.paths.length}. History length before save: ${state.history.length}`);
                }

                // æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿å­˜å†å²ï¼ˆé¿å…é‡å¤çŠ¶æ€ï¼‰
                const lastHistoryItem = state.history.length > 0 ? state.history[state.history.length - 1] : null;
                const shouldSave = !lastHistoryItem || 
                                  lastHistoryItem.hash !== currentStateHash || 
                                  lastHistoryItem.pathsCount !== pathsCopy.length;
                
                if (shouldSave) {
                    // å­˜å‚¨çŠ¶æ€å’Œå“ˆå¸Œå€¼
                    state.history.push({
                        paths: pathsCopy,
                        hash: currentStateHash,
                        pathsCount: pathsCopy.length,
                        timestamp: Date.now() // æ·»åŠ æ—¶é—´æˆ³ä¾¿äºè°ƒè¯•
                    });
                    
                    // é™åˆ¶å†å²è®°å½•é•¿åº¦
                    while (state.history.length > MAX_UNDO_STEPS) {
                        state.history.shift();
                    }
                    if (state.debug) {
                        console.log(`[UNDO LOG] History saved. New length: ${state.history.length}. Paths count: ${pathsCopy.length}`);
                    }
                } else {
                    if (state.debug) {
                        console.log("[UNDO LOG] History save skipped (state unchanged).");
                    }
                }
            } catch (error) {
                console.error("[UNDO LOG] Failed to save history:", error);
            }
            updateUndoButtonState();
        }

        function undo() {
            const state = canvasesState[currentCanvasIndex];
            if (state.debug) {
                console.log(`[UNDO LOG] Undo called. History length: ${state.history.length}`);
            }
            
            if (state.history.length > 0) {
                const previousState = state.history.pop();
                try {
                    // ç›´æ¥ä½¿ç”¨å­˜å‚¨çš„è·¯å¾„æ•°ç»„ï¼Œæ— éœ€è§£æJSON
                    if (Array.isArray(previousState.paths)) {
                        state.paths = previousState.paths;
                        if (state.debug) {
                            console.log(`[UNDO LOG] Undo successful. Restored paths count: ${state.paths.length}. History length after pop: ${state.history.length}`);
                        }
                        redrawCurrentCanvas();
                    } else {
                        throw new Error('Invalid paths data in history');
                    }
                } catch (error) {
                    console.error("[UNDO LOG] Failed to restore history state:", error);
                    // å°è¯•æ¢å¤åˆ°ä¸Šä¸€ä¸ªæœ‰æ•ˆçŠ¶æ€ï¼Œè€Œä¸æ˜¯ç›´æ¥æ¸…ç©º
                    if (state.history.length > 0) {
                        try {
                            const fallbackState = state.history.pop();
                            state.paths = fallbackState.paths;
                            console.log("[UNDO LOG] Recovered using previous history state");
                        } catch (fallbackError) {
                            // å¦‚æœæ¢å¤å¤±è´¥ï¼Œæ‰æ¸…ç©ºæ‰€æœ‰å†…å®¹
                            state.paths = [];
                            state.history = [];
                            console.error("[UNDO LOG] Failed to recover, clearing all states");
                        }
                    } else {
                        state.paths = []; // Fallback: clear paths if history is corrupted
                    }
                    redrawCurrentCanvas();
                }
            } else {
                if (state.debug) {
                    console.log("[UNDO LOG] Undo skipped (no history).");
                }
            }
            updateUndoButtonState();
        }

        function updateUndoButtonState() {
            const state = canvasesState[currentCanvasIndex];
            undoBtn.disabled = state.history.length === 0;
             // console.log("[UNDO LOG] Undo button state updated. Disabled:", undoBtn.disabled);
        }


        // --- ç•«æ¿åˆ‡æ› ---
        canvasBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.dataset.canvas);
                if (index >= 0 && index < 2 && index !== currentCanvasIndex) { // Check index bounds
                    switchCanvas(index);
                }
            });
        });

        function switchCanvas(index) {
            if (index >= 0 && index < 2) { // ä¿®æ”¹è¾¹ç•Œæ£€æŸ¥ä¸º2
                currentCanvasIndex = index;
                loadCanvasState(currentCanvasIndex);
                updateToolbar();
                redrawCurrentCanvas();
                updateUndoButtonState();
            }
        }

        function loadCanvasState(index) {
            // console.log(`Switched to canvas ${index}`);
        }

        // --- æ›´æ–°å·¥å…·æ¬„ç‹€æ…‹ ---
        function updateToolbar() {
            penBtn.classList.toggle('active', currentTool === 'pen');
            eraserBtn.classList.toggle('active', currentTool === 'eraser');
            canvasBtns.forEach(btn => {
                const btnIndex = parseInt(btn.dataset.canvas);
                if (btnIndex < 2) { // Only update buttons for existing canvases
                    btn.classList.toggle('active', btnIndex === currentCanvasIndex);
                }
            });
        }

        // --- åˆå§‹èªªæ˜ ---
        closeInstructionsBtn.addEventListener('click', () => {
            instructionsPanel.style.display = 'none';
        });

        // --- å¸®åŠ©æŒ‰é’®ç‚¹å‡»äº‹ä»¶ ---
        document.getElementById('help-btn').addEventListener('click', () => {
            instructionsPanel.style.display = 'flex';
        });

        // --- çª—å£å¤§å°èª¿æ•´ ---
        window.addEventListener('resize', debounce(resizeCanvas, 100));

        // é˜²æŠ–å‡½æ•¸
        function debounce(func, wait) { /* ... */ let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }

        // --- å•Ÿå‹• ---
        initializeCanvas();

    </script>

</body>
</html>

